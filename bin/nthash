#!/usr/bin/perl

# This is a cheap and cheerful way to anonymise RDF. Don't trust it.

use Getopt::Long;
use Digest::MD5 qw/ md5_hex /;
use strict;
use warnings;

my $prefixtohash;
my $namespace;
my $salt;
my $help;
my $sameas;

GetOptions (
            "prefix=s"   => \$prefixtohash,      
            "namespace=s"   => \$namespace,
            "salt=s"   => \$salt,
            "help"  => \$help,   # flag
            "sameas"  => \$sameas,   # flag
) or help(1);
help(0) if( $help );
help(1) if !defined $prefixtohash;
help(1) if !defined $namespace;

sub help
{
	my( $exitcode ) = @_;

	print STDERR <<END;
$0 --prefix <text> --namespace <text> [--salt <text>] [--sameas] <filename>

Note that this just obfuscates the URIs and is not a full solution to making
data anonymous. 

--prefix    <text> : required. The start of the URIs to anonymise.
--namespace <text> : required. Namespace in which to create new URIs.
--salt      <text> : optional. If included this will salt the hash with this 
                      value. Effectively a password to decode them later.
--sameas           : optional. If set this will output a list of sameAs 
                      triples to link from the original to the hashed URIs.
                      This must use the same value for --salt, if any.
END

	exit $exitcode;
}

@ARGV = ( "-" ) if( @ARGV == 0 ); #default to stdin
if( @ARGV != 1 )
{	
	error( "Did not specify a filename." );
}
my $filename = $ARGV[0];
my $fh;
if( $filename eq "-" )
{
	$fh = *STDIN;
}
else
{
	open( $fh, "<:utf8", $filename ) || error( "Could not read $filename: $!" );
}
my $seen = {}; # global
LINE: while( my $line = readline( $fh ) )
{
	############################################################
	# NTriples Line parser
	# Repeated in every script so they are stand alone but if there's
	# a bug it needs to be fixed in all the scripts
	############################################################
	chomp $line;
	$line =~ m/^(\<([^>]*)\>|(_:[^ ]*)) \<([^>]*)\> (\<([^>]*)\>|(_:[^ ]*)|"([^"]*)"(\^\^\<([^>]*)\>|\@([^ ]+))?) \.$/;
	my $s = $2||$3;
	my $p = $4;
	my $o = $6||$7||$8;
	my $islit = defined $8;
	my $ot = $10;
	my $ol = $11;
	############################################################
	my $s_bnode = defined $3;
	my $o_bnode = defined $7;

	if( $sameas )
	{
		sameas( $s );
		sameas( $p );
		sameas( $o );
		sameas( $ot );
		next LINE;
	}
		

	my( $sout, $pout, $oout, $otout );

	if( $s_bnode )
	{
		$sout = $s;
	}
	else
	{
		$sout = "<".process($s).">";
	}

	if( $o_bnode )
	{
		$oout = $o;
	}
	elsif( $islit )
	{
		$oout = "<".process($o).">";
	}

	# poor old p can't be a bnode
	$pout = "<".process($p).">";

	if( !$islit )
	{
		$oout = "<".process($o).">";
	}
	elsif( defined $ot )
	{
		$otout = "<".process($ot).">";
	}

	if( defined $ot )
	{
		print "$sout $pout \"$o\"^^$otout .\n";
	}
	elsif( defined $ol )
	{
		print "$sout $pout \"$o\"\@$ol .\n";
	}
	elsif( $islit )
	{
		print "$sout $pout \"$o\" .\n";
	}
	else
	{
		print "$sout $pout $oout .\n";
	}
}
exit;

sub process
{
	my( $uri) = @_;

	return undef if( !defined $uri );

	if( index( $uri, $prefixtohash ) == 0 )
	{
		return hashuri($uri);
	}
	
	return $uri;
}

sub hashuri
{
	my( $uri ) = @_;

	$uri.=$salt if( defined $salt );
	return $namespace.md5_hex( $uri );
}

# print the sameas for this uri if it is in scope, defined, and not seen before
sub sameas
{
	my( $uri ) = @_;

	return if !defined $uri; # might be an undefined otype
	return if index( $uri, $prefixtohash ) != 0;
	return if $seen->{$uri};

	print "<".hashuri($uri)."> <http://www.w3.org/2002/07/owl#sameAs> <$uri> .\n";
	$seen->{$uri} = 1;
}





sub error 
{
	my( $error ) = @_;

	print STDERR "$error\n";

	exit 1;
}


